all: target/LOCAL/index.js

# Install "node_modules"
node_modules/.done: package.json package-lock.json
	rm -rf node_modules
	npm clean-install
	@touch node_modules/.done

node_modules: node_modules/.done
	@touch node_modules

# Build the local NAPI module
target/LOCAL/index.js: Cargo.toml Cargo.lock package.json package-lock.json tsconfig.json node_modules $(shell find src -type f) build.rs utils/helpers.ts
	rm -rf target/LOCAL target/__TMP__
	npm run napi -- build --platform --release target/__TMP__/LOCAL $(NAPI_LOCAL_BUILD_ARGS)
	npm run prettier -- target/__TMP__/LOCAL/index.* --write --loglevel error
	rm -rf target/LOCAL
	cd target/__TMP__ && mv LOCAL ../
	rmdir target/__TMP__

# Top-level index.js file
index.js: target/LOCAL/index.js
	cp target/LOCAL/index.js target/LOCAL/index.d.ts .

# "index.d.ts" is generated by the rule that generates "index.js", but Make
# lacks a way to express this outcome
index.d.ts: index.js
	@true

# Local build in current directory
# Since the filename is isn't based on any of the inputs we can't create
# a rule for it, so we have a phony target
do-local-build:
	if [ -z '$(NAPI_TARGET)' ]; then \
		$(MAKE) target/LOCAL/index.js || exit 1; \
	else \
		$(MAKE) target/LOCAL/index.js NAPI_LOCAL_BUILD_ARGS="--target '$(NAPI_TARGET)'" || exit 1; \
	fi
	cp target/LOCAL/*.node .

# Run automated tests
test: node_modules target/LOCAL/index.js
	cargo test
	npm run ava

do-lint: node_modules
	npm run eslint -- -c ./.eslintrc.yml .
	rustfmt --check $(shell find src -type f)

# Run automated benchmarks
do-bench: node_modules target/LOCAL/index.js
	node -r @swc-node/register benchmark/bench.ts

# Create an npm package
do-npm-publish: node_modules do-local-build
	npm publish

# Remove generated files
clean:
	rm -rf target
	rm -f *.node index.js index.d.ts

# Remove generated and downloaded files
distclean: clean
	rm -rf node_modules

.PHONY: all test do-lint do-bench do-local-build do-npm-publish clean distclean
